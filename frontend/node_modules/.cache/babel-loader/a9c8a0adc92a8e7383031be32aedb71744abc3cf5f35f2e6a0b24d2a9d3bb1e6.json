{"ast":null,"code":"import { O as Ollama$1, h as head, p as post } from './shared/ollama.be8fd0da.mjs';\nimport fs, { promises, createReadStream } from 'fs';\nimport { resolve, join, dirname } from 'path';\nimport { createHash } from 'crypto';\nimport { homedir } from 'os';\nimport 'whatwg-fetch';\nclass Ollama extends Ollama$1 {\n  async encodeImage(image) {\n    if (typeof image !== \"string\") {\n      const result = Buffer.from(image).toString(\"base64\");\n      return result;\n    }\n    try {\n      if (fs.existsSync(image)) {\n        const fileBuffer = await promises.readFile(resolve(image));\n        return Buffer.from(fileBuffer).toString(\"base64\");\n      }\n    } catch {}\n    return image;\n  }\n  async parseModelfile(modelfile, mfDir = process.cwd()) {\n    const out = [];\n    const lines = modelfile.split(\"\\n\");\n    for (const line of lines) {\n      const [command, args] = line.split(\" \", 2);\n      if ([\"FROM\", \"ADAPTER\"].includes(command.toUpperCase())) {\n        const path = this.resolvePath(args.trim(), mfDir);\n        if (await this.fileExists(path)) {\n          out.push(`${command} @${await this.createBlob(path)}`);\n        } else {\n          out.push(`${command} ${args}`);\n        }\n      } else {\n        out.push(line);\n      }\n    }\n    return out.join(\"\\n\");\n  }\n  resolvePath(inputPath, mfDir) {\n    if (inputPath.startsWith(\"~\")) {\n      return join(homedir(), inputPath.slice(1));\n    }\n    return resolve(mfDir, inputPath);\n  }\n  async fileExists(path) {\n    try {\n      await promises.access(path);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async createBlob(path) {\n    if (typeof ReadableStream === \"undefined\") {\n      throw new Error(\"Streaming uploads are not supported in this environment.\");\n    }\n    const fileStream = createReadStream(path);\n    const sha256sum = await new Promise((resolve2, reject) => {\n      const hash = createHash(\"sha256\");\n      fileStream.on(\"data\", data => hash.update(data));\n      fileStream.on(\"end\", () => resolve2(hash.digest(\"hex\")));\n      fileStream.on(\"error\", reject);\n    });\n    const digest = `sha256:${sha256sum}`;\n    try {\n      await head(this.fetch, `${this.config.host}/api/blobs/${digest}`);\n    } catch (e) {\n      if (e instanceof Error && e.message.includes(\"404\")) {\n        const readableStream = new ReadableStream({\n          start(controller) {\n            fileStream.on(\"data\", chunk => {\n              controller.enqueue(chunk);\n            });\n            fileStream.on(\"end\", () => {\n              controller.close();\n            });\n            fileStream.on(\"error\", err => {\n              controller.error(err);\n            });\n          }\n        });\n        await post(this.fetch, `${this.config.host}/api/blobs/${digest}`, readableStream);\n      } else {\n        throw e;\n      }\n    }\n    return digest;\n  }\n  async create(request) {\n    let modelfileContent = \"\";\n    if (request.path) {\n      modelfileContent = await promises.readFile(request.path, {\n        encoding: \"utf8\"\n      });\n      modelfileContent = await this.parseModelfile(modelfileContent, dirname(request.path));\n    } else if (request.modelfile) {\n      modelfileContent = await this.parseModelfile(request.modelfile);\n    } else {\n      throw new Error(\"Must provide either path or modelfile to create a model\");\n    }\n    request.modelfile = modelfileContent;\n    if (request.stream) {\n      return super.create(request);\n    } else {\n      return super.create(request);\n    }\n  }\n}\nconst index = new Ollama();\nexport { Ollama, index as default };","map":{"version":3,"names":["O","Ollama$1","h","head","p","post","fs","promises","createReadStream","resolve","join","dirname","createHash","homedir","Ollama","encodeImage","image","result","Buffer","from","toString","existsSync","fileBuffer","readFile","parseModelfile","modelfile","mfDir","process","cwd","out","lines","split","line","command","args","includes","toUpperCase","path","resolvePath","trim","fileExists","push","createBlob","inputPath","startsWith","slice","access","ReadableStream","Error","fileStream","sha256sum","Promise","resolve2","reject","hash","on","data","update","digest","fetch","config","host","e","message","readableStream","start","controller","chunk","enqueue","close","err","error","create","request","modelfileContent","encoding","stream","index","default"],"sources":["/Users/albert/Desktop/web/my-app/node_modules/ollama/dist/index.mjs"],"sourcesContent":["import { O as Ollama$1, h as head, p as post } from './shared/ollama.be8fd0da.mjs';\nimport fs, { promises, createReadStream } from 'fs';\nimport { resolve, join, dirname } from 'path';\nimport { createHash } from 'crypto';\nimport { homedir } from 'os';\nimport 'whatwg-fetch';\n\nclass Ollama extends Ollama$1 {\n  async encodeImage(image) {\n    if (typeof image !== \"string\") {\n      const result = Buffer.from(image).toString(\"base64\");\n      return result;\n    }\n    try {\n      if (fs.existsSync(image)) {\n        const fileBuffer = await promises.readFile(resolve(image));\n        return Buffer.from(fileBuffer).toString(\"base64\");\n      }\n    } catch {\n    }\n    return image;\n  }\n  async parseModelfile(modelfile, mfDir = process.cwd()) {\n    const out = [];\n    const lines = modelfile.split(\"\\n\");\n    for (const line of lines) {\n      const [command, args] = line.split(\" \", 2);\n      if ([\"FROM\", \"ADAPTER\"].includes(command.toUpperCase())) {\n        const path = this.resolvePath(args.trim(), mfDir);\n        if (await this.fileExists(path)) {\n          out.push(`${command} @${await this.createBlob(path)}`);\n        } else {\n          out.push(`${command} ${args}`);\n        }\n      } else {\n        out.push(line);\n      }\n    }\n    return out.join(\"\\n\");\n  }\n  resolvePath(inputPath, mfDir) {\n    if (inputPath.startsWith(\"~\")) {\n      return join(homedir(), inputPath.slice(1));\n    }\n    return resolve(mfDir, inputPath);\n  }\n  async fileExists(path) {\n    try {\n      await promises.access(path);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  async createBlob(path) {\n    if (typeof ReadableStream === \"undefined\") {\n      throw new Error(\"Streaming uploads are not supported in this environment.\");\n    }\n    const fileStream = createReadStream(path);\n    const sha256sum = await new Promise((resolve2, reject) => {\n      const hash = createHash(\"sha256\");\n      fileStream.on(\"data\", (data) => hash.update(data));\n      fileStream.on(\"end\", () => resolve2(hash.digest(\"hex\")));\n      fileStream.on(\"error\", reject);\n    });\n    const digest = `sha256:${sha256sum}`;\n    try {\n      await head(this.fetch, `${this.config.host}/api/blobs/${digest}`);\n    } catch (e) {\n      if (e instanceof Error && e.message.includes(\"404\")) {\n        const readableStream = new ReadableStream({\n          start(controller) {\n            fileStream.on(\"data\", (chunk) => {\n              controller.enqueue(chunk);\n            });\n            fileStream.on(\"end\", () => {\n              controller.close();\n            });\n            fileStream.on(\"error\", (err) => {\n              controller.error(err);\n            });\n          }\n        });\n        await post(\n          this.fetch,\n          `${this.config.host}/api/blobs/${digest}`,\n          readableStream\n        );\n      } else {\n        throw e;\n      }\n    }\n    return digest;\n  }\n  async create(request) {\n    let modelfileContent = \"\";\n    if (request.path) {\n      modelfileContent = await promises.readFile(request.path, { encoding: \"utf8\" });\n      modelfileContent = await this.parseModelfile(\n        modelfileContent,\n        dirname(request.path)\n      );\n    } else if (request.modelfile) {\n      modelfileContent = await this.parseModelfile(request.modelfile);\n    } else {\n      throw new Error(\"Must provide either path or modelfile to create a model\");\n    }\n    request.modelfile = modelfileContent;\n    if (request.stream) {\n      return super.create(request);\n    } else {\n      return super.create(request);\n    }\n  }\n}\nconst index = new Ollama();\n\nexport { Ollama, index as default };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,QAAQ,EAAEC,CAAC,IAAIC,IAAI,EAAEC,CAAC,IAAIC,IAAI,QAAQ,8BAA8B;AAClF,OAAOC,EAAE,IAAIC,QAAQ,EAAEC,gBAAgB,QAAQ,IAAI;AACnD,SAASC,OAAO,EAAEC,IAAI,EAAEC,OAAO,QAAQ,MAAM;AAC7C,SAASC,UAAU,QAAQ,QAAQ;AACnC,SAASC,OAAO,QAAQ,IAAI;AAC5B,OAAO,cAAc;AAErB,MAAMC,MAAM,SAASb,QAAQ,CAAC;EAC5B,MAAMc,WAAWA,CAACC,KAAK,EAAE;IACvB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7B,MAAMC,MAAM,GAAGC,MAAM,CAACC,IAAI,CAACH,KAAK,CAAC,CAACI,QAAQ,CAAC,QAAQ,CAAC;MACpD,OAAOH,MAAM;IACf;IACA,IAAI;MACF,IAAIX,EAAE,CAACe,UAAU,CAACL,KAAK,CAAC,EAAE;QACxB,MAAMM,UAAU,GAAG,MAAMf,QAAQ,CAACgB,QAAQ,CAACd,OAAO,CAACO,KAAK,CAAC,CAAC;QAC1D,OAAOE,MAAM,CAACC,IAAI,CAACG,UAAU,CAAC,CAACF,QAAQ,CAAC,QAAQ,CAAC;MACnD;IACF,CAAC,CAAC,MAAM,CACR;IACA,OAAOJ,KAAK;EACd;EACA,MAAMQ,cAAcA,CAACC,SAAS,EAAEC,KAAK,GAAGC,OAAO,CAACC,GAAG,CAAC,CAAC,EAAE;IACrD,MAAMC,GAAG,GAAG,EAAE;IACd,MAAMC,KAAK,GAAGL,SAAS,CAACM,KAAK,CAAC,IAAI,CAAC;IACnC,KAAK,MAAMC,IAAI,IAAIF,KAAK,EAAE;MACxB,MAAM,CAACG,OAAO,EAAEC,IAAI,CAAC,GAAGF,IAAI,CAACD,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC;MAC1C,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC,CAACI,QAAQ,CAACF,OAAO,CAACG,WAAW,CAAC,CAAC,CAAC,EAAE;QACvD,MAAMC,IAAI,GAAG,IAAI,CAACC,WAAW,CAACJ,IAAI,CAACK,IAAI,CAAC,CAAC,EAAEb,KAAK,CAAC;QACjD,IAAI,MAAM,IAAI,CAACc,UAAU,CAACH,IAAI,CAAC,EAAE;UAC/BR,GAAG,CAACY,IAAI,CAAE,GAAER,OAAQ,KAAI,MAAM,IAAI,CAACS,UAAU,CAACL,IAAI,CAAE,EAAC,CAAC;QACxD,CAAC,MAAM;UACLR,GAAG,CAACY,IAAI,CAAE,GAAER,OAAQ,IAAGC,IAAK,EAAC,CAAC;QAChC;MACF,CAAC,MAAM;QACLL,GAAG,CAACY,IAAI,CAACT,IAAI,CAAC;MAChB;IACF;IACA,OAAOH,GAAG,CAACnB,IAAI,CAAC,IAAI,CAAC;EACvB;EACA4B,WAAWA,CAACK,SAAS,EAAEjB,KAAK,EAAE;IAC5B,IAAIiB,SAAS,CAACC,UAAU,CAAC,GAAG,CAAC,EAAE;MAC7B,OAAOlC,IAAI,CAACG,OAAO,CAAC,CAAC,EAAE8B,SAAS,CAACE,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5C;IACA,OAAOpC,OAAO,CAACiB,KAAK,EAAEiB,SAAS,CAAC;EAClC;EACA,MAAMH,UAAUA,CAACH,IAAI,EAAE;IACrB,IAAI;MACF,MAAM9B,QAAQ,CAACuC,MAAM,CAACT,IAAI,CAAC;MAC3B,OAAO,IAAI;IACb,CAAC,CAAC,MAAM;MACN,OAAO,KAAK;IACd;EACF;EACA,MAAMK,UAAUA,CAACL,IAAI,EAAE;IACrB,IAAI,OAAOU,cAAc,KAAK,WAAW,EAAE;MACzC,MAAM,IAAIC,KAAK,CAAC,0DAA0D,CAAC;IAC7E;IACA,MAAMC,UAAU,GAAGzC,gBAAgB,CAAC6B,IAAI,CAAC;IACzC,MAAMa,SAAS,GAAG,MAAM,IAAIC,OAAO,CAAC,CAACC,QAAQ,EAAEC,MAAM,KAAK;MACxD,MAAMC,IAAI,GAAG1C,UAAU,CAAC,QAAQ,CAAC;MACjCqC,UAAU,CAACM,EAAE,CAAC,MAAM,EAAGC,IAAI,IAAKF,IAAI,CAACG,MAAM,CAACD,IAAI,CAAC,CAAC;MAClDP,UAAU,CAACM,EAAE,CAAC,KAAK,EAAE,MAAMH,QAAQ,CAACE,IAAI,CAACI,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;MACxDT,UAAU,CAACM,EAAE,CAAC,OAAO,EAAEF,MAAM,CAAC;IAChC,CAAC,CAAC;IACF,MAAMK,MAAM,GAAI,UAASR,SAAU,EAAC;IACpC,IAAI;MACF,MAAM/C,IAAI,CAAC,IAAI,CAACwD,KAAK,EAAG,GAAE,IAAI,CAACC,MAAM,CAACC,IAAK,cAAaH,MAAO,EAAC,CAAC;IACnE,CAAC,CAAC,OAAOI,CAAC,EAAE;MACV,IAAIA,CAAC,YAAYd,KAAK,IAAIc,CAAC,CAACC,OAAO,CAAC5B,QAAQ,CAAC,KAAK,CAAC,EAAE;QACnD,MAAM6B,cAAc,GAAG,IAAIjB,cAAc,CAAC;UACxCkB,KAAKA,CAACC,UAAU,EAAE;YAChBjB,UAAU,CAACM,EAAE,CAAC,MAAM,EAAGY,KAAK,IAAK;cAC/BD,UAAU,CAACE,OAAO,CAACD,KAAK,CAAC;YAC3B,CAAC,CAAC;YACFlB,UAAU,CAACM,EAAE,CAAC,KAAK,EAAE,MAAM;cACzBW,UAAU,CAACG,KAAK,CAAC,CAAC;YACpB,CAAC,CAAC;YACFpB,UAAU,CAACM,EAAE,CAAC,OAAO,EAAGe,GAAG,IAAK;cAC9BJ,UAAU,CAACK,KAAK,CAACD,GAAG,CAAC;YACvB,CAAC,CAAC;UACJ;QACF,CAAC,CAAC;QACF,MAAMjE,IAAI,CACR,IAAI,CAACsD,KAAK,EACT,GAAE,IAAI,CAACC,MAAM,CAACC,IAAK,cAAaH,MAAO,EAAC,EACzCM,cACF,CAAC;MACH,CAAC,MAAM;QACL,MAAMF,CAAC;MACT;IACF;IACA,OAAOJ,MAAM;EACf;EACA,MAAMc,MAAMA,CAACC,OAAO,EAAE;IACpB,IAAIC,gBAAgB,GAAG,EAAE;IACzB,IAAID,OAAO,CAACpC,IAAI,EAAE;MAChBqC,gBAAgB,GAAG,MAAMnE,QAAQ,CAACgB,QAAQ,CAACkD,OAAO,CAACpC,IAAI,EAAE;QAAEsC,QAAQ,EAAE;MAAO,CAAC,CAAC;MAC9ED,gBAAgB,GAAG,MAAM,IAAI,CAAClD,cAAc,CAC1CkD,gBAAgB,EAChB/D,OAAO,CAAC8D,OAAO,CAACpC,IAAI,CACtB,CAAC;IACH,CAAC,MAAM,IAAIoC,OAAO,CAAChD,SAAS,EAAE;MAC5BiD,gBAAgB,GAAG,MAAM,IAAI,CAAClD,cAAc,CAACiD,OAAO,CAAChD,SAAS,CAAC;IACjE,CAAC,MAAM;MACL,MAAM,IAAIuB,KAAK,CAAC,yDAAyD,CAAC;IAC5E;IACAyB,OAAO,CAAChD,SAAS,GAAGiD,gBAAgB;IACpC,IAAID,OAAO,CAACG,MAAM,EAAE;MAClB,OAAO,KAAK,CAACJ,MAAM,CAACC,OAAO,CAAC;IAC9B,CAAC,MAAM;MACL,OAAO,KAAK,CAACD,MAAM,CAACC,OAAO,CAAC;IAC9B;EACF;AACF;AACA,MAAMI,KAAK,GAAG,IAAI/D,MAAM,CAAC,CAAC;AAE1B,SAASA,MAAM,EAAE+D,KAAK,IAAIC,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}